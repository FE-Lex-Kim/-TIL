- [실행 컨텍스트(Excution Context)](#실행-컨텍스트excution-context)
  - [1. 실행 컨텍스트가 생성되는 소스 코드 4개 타입](#1-실행-컨텍스트가-생성되는-소스-코드-4개-타입)
  - [2. 소스코드의 평가와 실행](#2-소스코드의-평가와-실행)
  - [3. 실행 컨텍스트의 실제 내부 값들](#3-실행-컨텍스트의-실제-내부-값들)
    - [전역 실행 컨텍스트](#전역-실행-컨텍스트)
    - [함수 실행 컨텍스트](#함수-실행-컨텍스트)
  - [5. 코드 실행 순서](#5-코드-실행-순서)
  - [결론](#결론)

<br>

# 실행 컨텍스트(Excution Context)

실행 컨텍스트는 **자바스크립트의 동작원리를 담고 있는 개념**이다.

<br>

스코프, 식별자 바인딩, 호이스팅, 클로저, 태스크 큐 .. 등등 자바스크립트의 동작 방식을 이해할 수 있다.

<br>

## 1. 실행 컨텍스트가 생성되는 소스 코드 4개 타입

자바스크립트는 소스코드를 4개 타입으로 구분한다.

**각각의 타입은 실행 컨텍스트를 생성한다.**

<br>

**소스코드를 4개 타입으로 구분하는 이유**는

- 실행 컨텍스트를 **생성하는 과정**과 **관리 내용**이 다르기 때문이다.

<br>

첫 번째로 전역 코드

두 번째로 함수 코드

세 번째로 eval 코드

네 번째로 모듈 코드

<br>

이렇게 4가지에 따라 실행 컨텍스트가 생성된다.

<br>

실행 컨텍스트를 설명하기 앞서

먼저 소스코드 평가와 실행에 대해 설명하겠다.

<br>

## 2. 소스코드의 평가와 실행

자바스크립트 엔진은

**소스코드의 평가**와 **소스코드의 실행**으로 나누어 처리한다.

<br>

**소스코드 평가** 과정때는 크게 3가지 과정을 거친다.

1. **실행 컨텍스트를 생성**한다.
2. 변수, 함수 등의 **선언문 만을 먼저 실행**한다.
3. 실행 컨텍스트가 관리하는 **스코프에 변수, 함수 식별자를 등록한다.**

<br>

**소스코드 실행** 과정 때는 크게 2가지 과정을 거친다.

1. 변수, 함수의 참조를 얻기위해 **실행 컨텍스트가 관리하는 스코프에서 검색하고 참조값을 얻는다.**
2. **소스코드의 실행 결과**는 다시 실행 컨텍스트가 관리하는 **스코프에 등록된다.**

<br>

## 3. 실행 컨텍스트의 실제 내부 값들

**코드가 평가 된다면 실행 컨텍스트를 생성한다.**

<br>

**전역 코드가 실행되서 생겨난 실행 컨텍스트를 전역 실행 컨텍스트라고 한다.**

**함수 코드에서 실행되서 생겨난 실행 컨텍스트를 함수 실행 컨텍스트라고 한다.**

<br>

### 전역 실행 컨텍스트

<br>

```jsx
// 전역 실행 컨텍스트
const GlobalExecutionContext = {
  LexicalEnvironment: { // 렉시컬 환경
    GlobalEnvironmentRecord: { // 환경 레코드
      ObjectEnvironmentRecord: { // 객체 환경 레코드
        BindingObject: Window, // 바인딩 오브젝 -> 윈도우 참조
      },
      DeclarativeEnvironmentRecord: { x: 2 }, // 선언적 환경 래코드
		[[GlobalThisValue]],
    },
    OuterLexicalEnvironmentReference: null, // 외부 환경에 대한 참조
  },
};
```

<br>

```jsx
LexicalEnvironment: { // 렉시컬 환경
  GlobalEnvironmentRecord: { // 환경 레코드
  OuterLexicalEnvironmentReference: null, // 외부 환경에 대한 참조
},
```

전역 실행 컨텍스트에는 **렉시컬 환경(Lexical Envioirment)이라는 객체 프로퍼티가 있다.**

렉시컬 환경의 값에서는 **두 가지 프로퍼티**가 있다.

첫 번째는 **환경 레코드(Global EnviormentRecord)**

두 번째는 **외부 렉시컬 환경에 대한 참조(outer Lexical Enviorment Reference)**

이렇게 두 가지가 있다.

<br>

```jsx
GlobalEnvironmentRecord: { // 환경 레코드
  ObjectEnvironmentRecord: { // 객체 환경 레코드
    BindingObject: Window, // 바인딩 오브젝 -> 윈도우 참조
  },
  DeclarativeEnvironmentRecord: { x: 2 }, // 선언적 환경 래코드
  [[GlobalThisValue]],
},
```

먼저 **환경 레코드**에 대해 설명하겠다.

환경 레코드의 값도 **세 가지의 프로퍼티**가 있다.

첫 번째 **객체 환경 레코드(Object Envioirment Record)**

두 번째 **선언적 환경 레코드(Declarative Envoirment Record)**

세 번째 **[[GlobalThisValue]]**

<br>

객체 환경 레코드는 **BindingObject 이라는 프로퍼티**가 있다.

BindingObject는 전역객체를 값으로 가지고 있다.

객체 환경레코드는 **var, 함수 선언문으로 정의된 값들이 BindingObject를 통해 전역객체의 프로퍼티로 등록된다.**

<br>

소스코드 평가과정때, **var 키워드로 선언된 변수는 전역객체에 undefined** 값이 할당된다.

함수 선언문으로 정의된 **함수는 이곳에 함수 객체가 할당된다.**

이것이 **호이스팅이 발생**할 수 있게 되는 원리이다.

<br>

다음으로 **선언적 환경 레코드**에 대해 설명하겠다.

ES6에 생겨난 **let, const 키워드의 값들이 이곳에 들어간다.**

<br>

마지막으로 **[[GlobalThisValue]]** 에 대해 설명하겠다.

일반적으로 전역에서 this를 사용하면, **전역객체가 값으로 나온다.**

따라서 항상 **[[GlobalThisValue]]의 값은 this의 값으로 전역객체를 가리키게 된다.**

<br>

다음으로 렉시컬 환경 레코드의 두 번째 프로퍼티인 **외부 렉시컬 환경에 대한 참조에 대해 설명하겠다.**

외부 렉시컬 환경에 대한 참조는 **상위 스코프 값이 이곳에 들어간다.**

따라서 **전역 실행 컨텍스트는 항상 최상위 스코프이므로 이곳에는 null 값이 들어간다.**

<br>

다음으로 **함수 실행 컨텍스트**에 대해 설명하겠다.

### 함수 실행 컨텍스트

```jsx
const FunctionExecutionContext = { // 함수 실행 컨텍스트
  LexicalEnvironment : { // 렉시컬 환경
    FunctionEnvironmentRecord :{ // 함수 환경 레코드
      FunctionEnvironmentRecord :{ x : 2}, // 함수 환경 레코드
      [[ThisValue]] // this
    },
    OuterLexicalEnvironmentReference : [상위스코프] // 외부 렉시컬 환경에 대한 참조
  },
}
```

<br>

함수 실행 컨텍스트는 전역 실행 컨텍스트와 살짝 내용이 다르다.

마찬가지로 함수 실행 컨텍스트의 프로퍼티로 **렉시컬 환경이 있다.**

<br>

```jsx
LexicalEnvironment : { // 렉시컬 환경
  FunctionEnvironmentRecord : {} // 함수 환경 레코드
  OuterLexicalEnvironmentReference : 상위 스코프 // 외부 렉시컬 환경에 대한 참조
},
```

렉시컬 환경에는 두 가지 프로퍼티 값이 있다.

첫 번째로 **함수 환경레코드**

두 번째로 **외부 렉시컬 환경에 대한 참조**

<br>

```jsx
FunctionEnvironmentRecord :{ // 함수 환경 레코드
    FunctionEnvironmentRecord :{ x : 2}, // 함수 환경 레코드
    [[ThisValue]] // this
},

```

첫 번째 **함수 환경 레코드**에 대해 설명하겠다.

함수 환경 레코드의 **프로퍼티는 두 가지**가 있다.

첫 번째는 **함수 환경 레코드**

두 번째는 **[[ThisValue]]**

<br>

**함수 환경 레코드**는 함수 내부의 **변수와 함수값들이 이곳에 들어있다.**

예를 들어) 함수의 인자인 arguments도 이곳에 있다.

**[[ThisValue]]는 this가 호출될때 이 값을 사용한다.**

<br>

this는 함수의 호출에 따라 변경된다.

따라서 **[[ThisValue]]는 함수의 호출에 따라 값이 각자 다르다.**

예를 들어) 일반 함수로 호출 되었다면, 이곳의 값은 **전역객체**가 된다.

<br>

```jsx
LexicalEnvironment : { // 렉시컬 환경
  FunctionEnvironmentRecord : {} // 함수 환경 레코드
  OuterLexicalEnvironmentReference : 상위 스코프 // 외부 렉시컬 환경에 대한 참조
},
```

두 번째인 **외부 렉시컬 환경에 대한 참조**에 대해 설명하겠다.

**외부 렉시컬 환경에 대한 참조의 값은 상위 스코프 이다.**

함수는 **정의된 곳에 따라 상위 스코프가 다르다.**

<br>

함수가 정의되었을때, **함수가 등록되어 있는 렉시컬 환경의 함수객체에** **[[Enviroment]]** 이 있다.

**[[Enviroment]]에는 함수가 정의된 순간 현재 실행중인 실행컨텍스트 값이 이곳에 들어간다.**

<br>

이후 함수가 호출되어 실행컨텍스트를 생성한다면,

**외부 렉시컬 환경에 대한 참조값은 [[Enviroment]]의 값을 사용한다.**

**즉, 외부 렉시컬 환경에 대한 참조값은 [[Enviroment]]이다.**

<br>

따라서 이렇게 실행 컨텍스트의 **렉시컬 환경의 값을 참조해서 식별자를 검색한다.**

먼저 실행 컨텍스트의 **렉시컬 환경을 검색하고 없다면 외부 렉시컬 환경에 대한 참조값을 검색한다.**

**스코프 체인이 구현되게 되는 실질적인 동작 원리이다.**

<br>

**이렇게 스코프체인이 동작하는 원리와 변수, 함수선언문이 등록되는 원리는 실행 컨텍스트에 의해 관리가 된다.**

<br>

다음으로는 **실행 컨텍스트의 실행 순서**에 대해 설명하겠다.

## 5. 코드 실행 순서

실행 컨텍스트는 콜 스택에 쌓이게 된다.

**실행 컨텍스트가 생성되는 코드는 4가지가 있다고 했었다.**

1. 전역 코드
2. 함수 코드
3. eval 코드
4. 모듈 코드

이중에서 코드에 실제로 사용되는 전역, 함수 코드에대해 설명하겠다.

<br>

가장 먼저 전역코드가 **평가되는 순간 콜 스택에 전역 실행 컨텍스트가 쌓이게 된다.**

평가가 종료된 이후, 소스 코드 실행과정, 즉 런타임에 순차적으로 코드가 실행된다.

<br>

이 과정에서 만약 **함수의 호출 코드을 만난다면, 함수 실행컨텍스트가 콜 스택에 쌓이게 된다.**

1. 전역 실행 컨텍스트
2. 함수 실행 컨텍스트

<br>

이후 함수 내부 코드의 평가와 실행 과정을 진행한다.

모든 함수 내부 코드가 종료된다면, **콜 스택에 현재 진행중이 였던 함수 실행 컨텍스트가 제거된다.**

그리고 **다시 전역 실행 컨텍스트로 진행된다.**

<br>

**이렇게 코드의 실행 순서는 콜 스택에 실행 컨텍스트가 쌓이는 순서에 따라 결정된다.**

<br>

## 결론

자바스크립트 코드가 실행하기 위해서는 **스코프, 식별자, 코드 실행 순서등 관리가 필요하다.**

- 식별자들의 값을 관리해야한다.
- 스코프체인을 검색할 수 있어야한다.
- 코드의 실행순서를 관리해야한다.

<br>

이 모든 것을 실행 컨텍스트가 한다.

<br>

**즉, 실행 컨텍스트는 스코프와 코드 실행 순서를 모두 관리한다.**

**식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리**하고

**코드 실행 순서는 실행 컨텍스트 스택, 즉 콜 스택으로 관리**한다.

<br>

참고

- 책 : 모던 자바스크립트 deep dive
