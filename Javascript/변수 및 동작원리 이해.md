# 변수

- 출처 [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567?OzSrank=1)을 보고 정리한 내용입니다.

## 1. 연산된 값이 메모리에 저장되는 과정

<br>
CPU의 연산계산 → 각 메모리 셀이 가지고 있는 메모리 주소에 저장

🤔 메모리 주소에 직접 접근 하면 안된다. **Why?**

1. 운영체제가 사용하고 있는 값을 **변경**하면 치명적 오류가 발생한다.
2. 코드 실행 될때마다 메모리 주소가 바뀌어서 알수가 없다.

<br>

**How? 그럼 어떻게 메모리 주소에 있는 값을 참조할수 있을까?**

하나의 값을 저장하기 위한 메모리 공간 자체에 식별하기 위한 이름을 부여해서 참조한다!

그것을 **변수[용어]** 라고 부른다.

<br>

**변수**는 **값의 위치를 가리키는 상징적인 이름** 이다

<br>

변수에 값을 저장하는것을 **할당(assignment)[용어]** 라고한다.

그렇다면 변수에 값을 부르는것은? **참조(reference)[용어]** 라고 한다!

<br>

**How? 그럼 어떻게 변수에 있는 값을 어떻게 가져올까? 동작방식이 무엇일까?**

프로그래밍 언어의 **컴파일러[용어]** / **인터프린터[용어]** 에 의해서

**변수**는 값이 저장된 **메모리 공간의 주소**로 바꿔서 실행한다.

<br>

## 2. 식별자 → 질문) 매핑관계?

<br>

변수이름 = **식별자[용어]**

<br>

식별자는 메모리 주소를 기억하고 있다.

→ 그곳을 접근 가능하게 해준다.

<br>

**식별자**는 **메모리 주소에 붙인 이름** 이다.

<br>

**?? 그렇다면 변수만 식별자라 부를까?**

→ X / 메모리 상에 존재하는 어떤값을 식별하게 하는 것을 **식별자**라고 부른다!

<br>

**How ? 그렇다면 식별자를 어떻게 자바스크립트 엔진에 알릴까?**

<br>

## 3. 변수 선언

<br>

**식별자**를 자바스크립트 엔진에 알려주는 것을 **선언(declaration)[용어]** 이라고 부른다.

<br>

**How? 선언을 하면 어떻게 될까?**

1. 변수를 **선언** 한다.
2. 메모리 공간을 **확보**한다.
3. **`변수 이름`** 과 **`확보된 메모리 공간의 주소`** 이 둘을 **연결** 한다.
4. **값 저장 준비**를 한다.

<br>

**How? 무엇을 써서 어떻게 선언을 할까?**

자바스크립트에 **키워드[용어]** 를 사용해서 선언을 한다.

→ var, let, const

<br>

### **3-1. ES5 VS ES6**

<br>

ES5 → var

ES6 → let, const

<br>

var는 전역변수가 되서 부작용을 발생한다.

var의 **단점**을 보안하기위해 ES6에서는 `let` 과 `const` 가 추가되었다.

<br>

**What? 그렇다면 키워드[용어]는 무엇일까?**

키워드 : JS 엔진이 수행할 동작 명령어

→ 엔진이 키워드를 만나면 **약속된 동작을 수행**한다.

Ex) var, let, const, break, case...

<br>

예를들어 var, let, const를 쓰면

**'뒤에 오는 변수이름으로 선언'** 을 **수행**한다.

<br>

수행후 값을 **할당[용어]** 하지 않아도 `undefined`가 **암묵적**으로 할당된다.

→ 이러한 과정을 **초기화[용어]** 된다고 표현한다.

<br>

**What? undefined 가 무엇일까?**

→ JS에서 제공하는 원시타잆의 값.

<br>

**Why? 왜 초기화 단계를 거치나?**

메모리 공간안에 이전의 **다른 애플리케이션이 사용한 값** 이 있을수 있다.

→ 이러한 값을 **쓰레기값(grabage value)[용어]** 라고한다.

초기화 하지 않고 변수 값을 참조하면 이 쓰레기 값이 나올수도 있다.

1. 공간확보.
2. 초기화 하여 쓰레기 값을 초기화.

   → 암묵적인 초기화를 수행하므로 안전하다.

   <br>

## 4. 변수 선언의 실행 시점과 변수 호이스팅

<br>

```jsx
console.log(score); //undefined
var score;
```

위에서 부터 순차적으로 실행하는 인터프린터에 의해 `undefined` 가 안뜨고

참조 에러(ReferenceError)가 발생 할줄 알았지만

<br>

소스코드가 순차적으로 실행되는 **런타임[용어]** 때 변수가 선언되는 것이아니라,

<br>

그 이전에 **소스코드 평가 과정** 때 **선언**이 된다.

<br>

JS엔진은 변수 선언을 포함한 모든 **선언문**을 먼저 **실행**한다.

→ 이러한 동작을 **변수 호이스팅[용어]** 이라고 한다.

<br>

**What? 그렇다면 선언문으로서 먼저 실행되는 키워드는 어떤게 있을까?**

`var, let, const, function, function*, class` 를 사용하는 모든 **식별자**가 **호이스팅** 된다.

<br>

## 5. 값의 할당

<br>

변수에 값을 할당 할땐

**할당 연산자(=)[용어]** 를 사용한다.

```jsx
var score = 80;
```

**But** **할당**한다고 해도

**'소스코드 평가 과정'** 시간때 **선언**은 먼저 **실행**되지만,

**값의** **할당**은 **'런타임'** 시간때 **실행**된다.

<br>

```jsx
var score;
socre = 80;
```

위의 예시와 밑의 예시 둘은 똑같다 .

<br>

## 6. 값의 재할당

<br>

**이미 값**이 **할당**되어 있는 **변수**에 **새로운 값을 다시 할당** 하는 것을

**재할당[용어]** 이라고한다.

<br>

**But** 처음 변수를 선언시 **초기화**를 통해 `undefined` 로 할당된뒤(1)

<br>

`undefined` 에서 새롭게 할당하므로 처음 값을 할당을 할때도(2) 사실은 **재할당**이다.

<br>

**How? 어떤 동작원리?**

처음에 변수에 할당 할때처럼

**기존의 공간에 넣는 것**이 아닌 새로운

메모리 공간을 확보 한뒤 할당한다.

<br>

**기존의 공간에 넣는것**

→ 이러한 기존의 메모리 공간의 값은 더이상

어떤한 식별자와 **연결** 안되있는 **쓰레기 값[용어]** 이된다.

<br>

1. 공간확보
2. 할당

<br>

**How? 쓰레기 값들은 그럼 계속 남아있나?**

이러한 **쓰레기 값**들을 **가비지 콜렉터[용어]** 를

통해 메모리가 **자동으로 해제**된다.

<br>

**What? 가비지 콜렉터가 무엇일까?**

**주기적**으로 식별자와 연결되지 않은 **메모리 공간을 해제**하는 것이다.

<br>

**What? 자동으로 해제?**

<br>

**언매니지드 언어 VS 매니지드 언어**

<br>

JS 엔진에서 **가비지 콜렉터를 내장**하여

자동으로 메모리를 해제하는 언어를 **매니지드 언어[용어]** 라고한다.

<br>

그 반대로 **직접 개발자**가 메모리를 할당 및 해제

해야하는 언어를 **언매니지드 언어[용어]** 라고한다.

<br>

**What? 무슨 장단점이 있을까?**

**언매니지드**

→ 개발자가 직접 주도하므로 성능을 최적으로 만들 수 있다.(장점)

but 직접 주도하므로 실수를 할시 치명적 오류를 발생 가능성이 있다.(단점)

<br>

**매니지드**

→ 개발자의 의존 부분이 떨어져 생산성을 확보한다.(장점)

but 엔진에서 메모리를 **언제 해제될지는 예측 할수 없어** 어느정도의 **성능 손실이 발생**한다.(단점)

<br>

## 7. 식별자 네이밍 규칙

<br>

식별자는 어떠한 값을 정확히 식별 할 수 있도록 네이미을 구체적으로 해야한다.

네이밍은 규칙이 있다.

1. 특수문자를 제외한 문자, 숫자, 언더스코어( \_ ), 달러기호($)
2. 숫자로 시작하면 안된다.
3. **예약어[용어]** 와 같은 이름으로 하면안된다.

<br>

변수에 주석이 필요한 정도면

좋지않은 네이밍을 한것이다.

```jsx
var a = 80; // 좋지않음! 삐!

var socre = 80; // 어떤 의미의 값인지 알수 있음 딩동댕!
```

정말 구체적으로 적자!

<br>

네이밍은 **하나이상의 영단어**로 구성된

식별자를 만들때 가독성을 좋게 해야한다.

<br>

```jsx
var firstName; // 카멜케이스

var FirstName; // 파스칼 케이스
```

1. 변수, 함수 → 카멜케이스
2. 생성자 함수, 클래스 → 파스칼 케이스

**권장!**
