# 캐시 검증 헤더와 조건부 요청

**만약 캐시 유효기간이 초과 했지만,** **실제로 서버에서는 해당 데이터에 대한 내용이 변한것이 하나도 없다면?**

<br>

그래도 똑같이 서버에 그 데이터를 요청하고 **데이터 값을 모두 다 가져온다.(단지 캐시 유효기간이 초과했다고 서버에서 모든 데이터를 가져옴)**

<br>

이렇게 불필요한 요청을 다시한번 막는 방법이 있다.

그것은 **검증 헤더와 조건부 요청 이다.(2가지 방법이 있다.)**

<br>

- 캐시 만료후에도 서버에서 데이터를 변경하지 않아야함
- 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있다.
- 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.

<br>

## `Last-Modified` , `if-modified-since`

![스크린샷 2021-09-20 오후 7.00.19.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd181444-7abb-497c-997e-1f1b11c7a92a/스크린샷_2021-09-20_오후_7.00.19.png)

`Last-Modified` 와 `if-modified-since` 를 사용한다.

<br>

프로세스

최초 요청

1. 서버에게 **데이터 요청**
2. 서버에서 이미지 **데이터 1.1M 응답**
   - HTTP 헤더 부분에 `Last-Modified` 에 마지막으로 해당 데이터를 변경한 날짜를 적어 놓는다.**(최종 수정일)**
3. 브라우저 캐시에 **응답 결과를 저장한다.**
   - 데이터 **최종 수정일과** **유효기간**을 같이 저장한다.

<br>

두 번째 재요청 - 캐시 시간 초과

1. HTTP 메서드로 **해당 데이터 요청을 한다.**(클라이언트)
2. 서버에 가기전 자동으로 **브라우저 캐시를 탐색**해 해당 데이터가 있는지 탐색한다.
3. **유효시간인 60초가 초과**한것을 확인한다.
4. 서버에 캐시가 가지고 있는 데이터 **최종 수정일인 `if-modified-since` 를 헤더**에 담아 요청한다.
5. 서버에 해당 데이터의 **최종 수정일과 일치**한다면 데이터가 아직 수정되지 않았다는 의미이므로 `**304 Not Modified` 와 `max-age`\*\* 을 HTTP 헤더에 담아 응답한다.(0.1M 전송, 헤더의 데이터만)
6. 기존에 있던 **브라우저 캐시의 데이터를 재사용**하고 다시 **유효시간을 갱신한다.**

<br>

정리

- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면
- **304 Not Modified + 헤더 메타 정보만 응답**(바디X)
- 클라이언트는 서버가 보낸 응답 헤더 정보로 **캐시의 메타 정보 갱신**
- 클라이언트는 **캐시에 저장되어 있는 데이터 재활용**
- 결과적으로 네
  <br>
  트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 한다.

**만약 실제 캐쉬의 최종 수정일이 서버와 다르다면 모든 데이터와 200 OK 를 같이 담아 보낸다.**

<br>

## `ETag`, `If-None-Match`

두번째 방법이다.

<br>

`Last-Modified`, `if-Modified-Since` 단점이 있다.

- **날짜 기반**의 로직을 사용한다.(복잡함, 각각 날짜를 비교하는 알고리즘이 필요함)
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 **데이터 결과가 똑같은 경우**(복사 붙여넣기 같은 경우라도 최종 수정일이 수정됨)
- **서버에서 별도의 캐시 로직을 관리**하고 싶은 경우
  - 예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

<br>

`ETag`, `If-None-Match` 를 사용하는 방법

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 **고유한 버전 이름**을 달아둔다.
  - ex) ETag: "v1.0", ETag: "aaa"
- **데이터가 변경되면 이 이름을 바꾸어서 변경함**(Hash를 다시 생성한다고 말한다.)
  - ex) ETag: "v1.0" → ETag: "v1.1" → ETag: "v1.2"
- ETag만 보내서 **같으면 유지, 다르면 다시 받기**

  ![스크린샷 2021-09-20 오후 7.34.59.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e681b19b-826d-4fcf-9575-952c430b5047/스크린샷_2021-09-20_오후_7.34.59.png)

<br>

프로세스

최초 요청

1. 서버에게 **데이터 요청**
2. **응답 결과**를 브라우저 캐시에 저장
   - `ETag`와 `cache-control: max-age=60` 도 같이 저장

<br>

두 번째 재요청 - 캐시 유효 기간 만료

1. 서버에게 **데이터 요청**
2. **브라우저 캐시에서 데이터 탐색**
3. 유효 기간 **만료된것을 확인**
4. HTTP 헤더의 `**if-None-Match` 에 ETag\*\*를 넣어서 데이터에 대한 변경이 있는지 확인하기 위해 요청한다.
5. **서버에서 변경이 되지 않았다면**(ETag 값이 동일)
6. `**304 Not Modified`와 `ETag`, `max-age` 를 HTTP 헤더만 전송한다.\*\*
7. 브라우저 캐시의 정보를 **HTTP 헤더값으로 갱신**한다.
8. 웹 브라우저는 **캐시 데이터를 사용한다.**

<br>

정리

- ETag만 서버에 보내서 **같으면 유지, 다르면 다시 받는다.**
- 캐시 제어 로직을 **서버에서 완전히 관리한다.**
- 클라이언트는 **단순히 이 값을 서버에 제공**한다.
  - ex)
  - 서버는 베타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지
  - 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신

<br>

참고

- 모든 개발자를 위한 HTTP 웹 기본지식 인프런 강의
